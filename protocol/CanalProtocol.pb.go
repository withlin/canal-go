// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: CanalProtocol.proto

package com_alibaba_otter_canal_protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Compression int32

const (
	Compression_COMPRESSIONCOMPATIBLEPROTO2 Compression = 0
	Compression_NONE                        Compression = 1
	Compression_ZLIB                        Compression = 2
	Compression_GZIP                        Compression = 3
	Compression_LZF                         Compression = 4
)

var Compression_name = map[int32]string{
	0: "COMPRESSIONCOMPATIBLEPROTO2",
	1: "NONE",
	2: "ZLIB",
	3: "GZIP",
	4: "LZF",
}
var Compression_value = map[string]int32{
	"COMPRESSIONCOMPATIBLEPROTO2": 0,
	"NONE":                        1,
	"ZLIB":                        2,
	"GZIP":                        3,
	"LZF":                         4,
}

func (x Compression) String() string {
	return proto.EnumName(Compression_name, int32(x))
}
func (Compression) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{0}
}

type PacketType int32

const (
	// compatible
	PacketType_PACKAGETYPECOMPATIBLEPROTO2 PacketType = 0
	PacketType_HANDSHAKE                   PacketType = 1
	PacketType_CLIENTAUTHENTICATION        PacketType = 2
	PacketType_ACK                         PacketType = 3
	PacketType_SUBSCRIPTION                PacketType = 4
	PacketType_UNSUBSCRIPTION              PacketType = 5
	PacketType_GET                         PacketType = 6
	PacketType_MESSAGES                    PacketType = 7
	PacketType_CLIENTACK                   PacketType = 8
	// management part
	PacketType_SHUTDOWN PacketType = 9
	// integration
	PacketType_DUMP           PacketType = 10
	PacketType_HEARTBEAT      PacketType = 11
	PacketType_CLIENTROLLBACK PacketType = 12
)

var PacketType_name = map[int32]string{
	0:  "PACKAGETYPECOMPATIBLEPROTO2",
	1:  "HANDSHAKE",
	2:  "CLIENTAUTHENTICATION",
	3:  "ACK",
	4:  "SUBSCRIPTION",
	5:  "UNSUBSCRIPTION",
	6:  "GET",
	7:  "MESSAGES",
	8:  "CLIENTACK",
	9:  "SHUTDOWN",
	10: "DUMP",
	11: "HEARTBEAT",
	12: "CLIENTROLLBACK",
}
var PacketType_value = map[string]int32{
	"PACKAGETYPECOMPATIBLEPROTO2": 0,
	"HANDSHAKE":                   1,
	"CLIENTAUTHENTICATION":        2,
	"ACK":                         3,
	"SUBSCRIPTION":                4,
	"UNSUBSCRIPTION":              5,
	"GET":                         6,
	"MESSAGES":                    7,
	"CLIENTACK":                   8,
	"SHUTDOWN":                    9,
	"DUMP":                        10,
	"HEARTBEAT":                   11,
	"CLIENTROLLBACK":              12,
}

func (x PacketType) String() string {
	return proto.EnumName(PacketType_name, int32(x))
}
func (PacketType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{1}
}

type Packet struct {
	// [default = 17];
	//
	// Types that are valid to be assigned to MagicNumberPresent:
	//	*Packet_MagicNumber
	MagicNumberPresent isPacket_MagicNumberPresent `protobuf_oneof:"magic_number_present"`
	// [default = 1];
	//
	// Types that are valid to be assigned to VersionPresent:
	//	*Packet_Version
	VersionPresent isPacket_VersionPresent `protobuf_oneof:"version_present"`
	Type           PacketType              `protobuf:"varint,3,opt,name=type,proto3,enum=com.alibaba.otter.canal.protocol.PacketType" json:"type,omitempty"`
	// [default = NONE];
	//
	// Types that are valid to be assigned to CompressionPresent:
	//	*Packet_Compression
	CompressionPresent   isPacket_CompressionPresent `protobuf_oneof:"compression_present"`
	Body                 []byte                      `protobuf:"bytes,5,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Packet) Reset()         { *m = Packet{} }
func (m *Packet) String() string { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()    {}
func (*Packet) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{0}
}
func (m *Packet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Packet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet.Merge(dst, src)
}
func (m *Packet) XXX_Size() int {
	return m.Size()
}
func (m *Packet) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet.DiscardUnknown(m)
}

var xxx_messageInfo_Packet proto.InternalMessageInfo

type isPacket_MagicNumberPresent interface {
	isPacket_MagicNumberPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPacket_VersionPresent interface {
	isPacket_VersionPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPacket_CompressionPresent interface {
	isPacket_CompressionPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Packet_MagicNumber struct {
	MagicNumber int32 `protobuf:"varint,1,opt,name=magic_number,json=magicNumber,proto3,oneof"`
}
type Packet_Version struct {
	Version int32 `protobuf:"varint,2,opt,name=version,proto3,oneof"`
}
type Packet_Compression struct {
	Compression Compression `protobuf:"varint,4,opt,name=compression,proto3,enum=com.alibaba.otter.canal.protocol.Compression,oneof"`
}

func (*Packet_MagicNumber) isPacket_MagicNumberPresent() {}
func (*Packet_Version) isPacket_VersionPresent()         {}
func (*Packet_Compression) isPacket_CompressionPresent() {}

func (m *Packet) GetMagicNumberPresent() isPacket_MagicNumberPresent {
	if m != nil {
		return m.MagicNumberPresent
	}
	return nil
}
func (m *Packet) GetVersionPresent() isPacket_VersionPresent {
	if m != nil {
		return m.VersionPresent
	}
	return nil
}
func (m *Packet) GetCompressionPresent() isPacket_CompressionPresent {
	if m != nil {
		return m.CompressionPresent
	}
	return nil
}

func (m *Packet) GetMagicNumber() int32 {
	if x, ok := m.GetMagicNumberPresent().(*Packet_MagicNumber); ok {
		return x.MagicNumber
	}
	return 17
}

func (m *Packet) GetVersion() int32 {
	if x, ok := m.GetVersionPresent().(*Packet_Version); ok {
		return x.Version
	}
	return 1
}

func (m *Packet) GetType() PacketType {
	if m != nil {
		return m.Type
	}
	return PacketType_PACKAGETYPECOMPATIBLEPROTO2
}

func (m *Packet) GetCompression() Compression {
	if x, ok := m.GetCompressionPresent().(*Packet_Compression); ok {
		return x.Compression
	}
	return Compression_NONE
}

func (m *Packet) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Packet) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Packet_OneofMarshaler, _Packet_OneofUnmarshaler, _Packet_OneofSizer, []interface{}{
		(*Packet_MagicNumber)(nil),
		(*Packet_Version)(nil),
		(*Packet_Compression)(nil),
	}
}

func _Packet_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Packet)
	// magic_number_present
	switch x := m.MagicNumberPresent.(type) {
	case *Packet_MagicNumber:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.MagicNumber))
	case nil:
	default:
		return fmt.Errorf("Packet.MagicNumberPresent has unexpected type %T", x)
	}
	// version_present
	switch x := m.VersionPresent.(type) {
	case *Packet_Version:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Version))
	case nil:
	default:
		return fmt.Errorf("Packet.VersionPresent has unexpected type %T", x)
	}
	// compression_present
	switch x := m.CompressionPresent.(type) {
	case *Packet_Compression:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Compression))
	case nil:
	default:
		return fmt.Errorf("Packet.CompressionPresent has unexpected type %T", x)
	}
	return nil
}

func _Packet_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Packet)
	switch tag {
	case 1: // magic_number_present.magic_number
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MagicNumberPresent = &Packet_MagicNumber{int32(x)}
		return true, err
	case 2: // version_present.version
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.VersionPresent = &Packet_Version{int32(x)}
		return true, err
	case 4: // compression_present.compression
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.CompressionPresent = &Packet_Compression{Compression(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Packet_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Packet)
	// magic_number_present
	switch x := m.MagicNumberPresent.(type) {
	case *Packet_MagicNumber:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.MagicNumber))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// version_present
	switch x := m.VersionPresent.(type) {
	case *Packet_Version:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Version))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// compression_present
	switch x := m.CompressionPresent.(type) {
	case *Packet_Compression:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Compression))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HeartBeat struct {
	SendTimestamp        int64    `protobuf:"varint,1,opt,name=send_timestamp,json=sendTimestamp,proto3" json:"send_timestamp,omitempty"`
	StartTimestamp       int64    `protobuf:"varint,2,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartBeat) Reset()         { *m = HeartBeat{} }
func (m *HeartBeat) String() string { return proto.CompactTextString(m) }
func (*HeartBeat) ProtoMessage()    {}
func (*HeartBeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{1}
}
func (m *HeartBeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartBeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartBeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HeartBeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartBeat.Merge(dst, src)
}
func (m *HeartBeat) XXX_Size() int {
	return m.Size()
}
func (m *HeartBeat) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartBeat.DiscardUnknown(m)
}

var xxx_messageInfo_HeartBeat proto.InternalMessageInfo

func (m *HeartBeat) GetSendTimestamp() int64 {
	if m != nil {
		return m.SendTimestamp
	}
	return 0
}

func (m *HeartBeat) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

type Handshake struct {
	//  [default = "utf8"];
	//
	// Types that are valid to be assigned to CommunicationEncodingPresent:
	//	*Handshake_CommunicationEncoding
	CommunicationEncodingPresent isHandshake_CommunicationEncodingPresent `protobuf_oneof:"communication_encoding_present"`
	Seeds                        []byte                                   `protobuf:"bytes,2,opt,name=seeds,proto3" json:"seeds,omitempty"`
	SupportedCompressions        Compression                              `protobuf:"varint,3,opt,name=supported_compressions,json=supportedCompressions,proto3,enum=com.alibaba.otter.canal.protocol.Compression" json:"supported_compressions,omitempty"`
	XXX_NoUnkeyedLiteral         struct{}                                 `json:"-"`
	XXX_unrecognized             []byte                                   `json:"-"`
	XXX_sizecache                int32                                    `json:"-"`
}

func (m *Handshake) Reset()         { *m = Handshake{} }
func (m *Handshake) String() string { return proto.CompactTextString(m) }
func (*Handshake) ProtoMessage()    {}
func (*Handshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{2}
}
func (m *Handshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Handshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Handshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Handshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Handshake.Merge(dst, src)
}
func (m *Handshake) XXX_Size() int {
	return m.Size()
}
func (m *Handshake) XXX_DiscardUnknown() {
	xxx_messageInfo_Handshake.DiscardUnknown(m)
}

var xxx_messageInfo_Handshake proto.InternalMessageInfo

type isHandshake_CommunicationEncodingPresent interface {
	isHandshake_CommunicationEncodingPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Handshake_CommunicationEncoding struct {
	CommunicationEncoding string `protobuf:"bytes,1,opt,name=communication_encoding,json=communicationEncoding,proto3,oneof"`
}

func (*Handshake_CommunicationEncoding) isHandshake_CommunicationEncodingPresent() {}

func (m *Handshake) GetCommunicationEncodingPresent() isHandshake_CommunicationEncodingPresent {
	if m != nil {
		return m.CommunicationEncodingPresent
	}
	return nil
}

func (m *Handshake) GetCommunicationEncoding() string {
	if x, ok := m.GetCommunicationEncodingPresent().(*Handshake_CommunicationEncoding); ok {
		return x.CommunicationEncoding
	}
	return ""
}

func (m *Handshake) GetSeeds() []byte {
	if m != nil {
		return m.Seeds
	}
	return nil
}

func (m *Handshake) GetSupportedCompressions() Compression {
	if m != nil {
		return m.SupportedCompressions
	}
	return Compression_COMPRESSIONCOMPATIBLEPROTO2
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Handshake) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Handshake_OneofMarshaler, _Handshake_OneofUnmarshaler, _Handshake_OneofSizer, []interface{}{
		(*Handshake_CommunicationEncoding)(nil),
	}
}

func _Handshake_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Handshake)
	// communication_encoding_present
	switch x := m.CommunicationEncodingPresent.(type) {
	case *Handshake_CommunicationEncoding:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.CommunicationEncoding)
	case nil:
	default:
		return fmt.Errorf("Handshake.CommunicationEncodingPresent has unexpected type %T", x)
	}
	return nil
}

func _Handshake_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Handshake)
	switch tag {
	case 1: // communication_encoding_present.communication_encoding
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.CommunicationEncodingPresent = &Handshake_CommunicationEncoding{x}
		return true, err
	default:
		return false, nil
	}
}

func _Handshake_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Handshake)
	// communication_encoding_present
	switch x := m.CommunicationEncodingPresent.(type) {
	case *Handshake_CommunicationEncoding:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.CommunicationEncoding)))
		n += len(x.CommunicationEncoding)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// client authentication
type ClientAuth struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password []byte `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// [default = 0]
	//
	// Types that are valid to be assigned to NetReadTimeoutPresent:
	//	*ClientAuth_NetReadTimeout
	NetReadTimeoutPresent isClientAuth_NetReadTimeoutPresent `protobuf_oneof:"net_read_timeout_present"`
	// [default = 0];
	//
	// Types that are valid to be assigned to NetWriteTimeoutPresent:
	//	*ClientAuth_NetWriteTimeout
	NetWriteTimeoutPresent isClientAuth_NetWriteTimeoutPresent `protobuf_oneof:"net_write_timeout_present"`
	Destination            string                              `protobuf:"bytes,5,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId               string                              `protobuf:"bytes,6,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Filter                 string                              `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter,omitempty"`
	StartTimestamp         int64                               `protobuf:"varint,8,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                            `json:"-"`
	XXX_unrecognized       []byte                              `json:"-"`
	XXX_sizecache          int32                               `json:"-"`
}

func (m *ClientAuth) Reset()         { *m = ClientAuth{} }
func (m *ClientAuth) String() string { return proto.CompactTextString(m) }
func (*ClientAuth) ProtoMessage()    {}
func (*ClientAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{3}
}
func (m *ClientAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientAuth.Merge(dst, src)
}
func (m *ClientAuth) XXX_Size() int {
	return m.Size()
}
func (m *ClientAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientAuth.DiscardUnknown(m)
}

var xxx_messageInfo_ClientAuth proto.InternalMessageInfo

type isClientAuth_NetReadTimeoutPresent interface {
	isClientAuth_NetReadTimeoutPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isClientAuth_NetWriteTimeoutPresent interface {
	isClientAuth_NetWriteTimeoutPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientAuth_NetReadTimeout struct {
	NetReadTimeout int32 `protobuf:"varint,3,opt,name=net_read_timeout,json=netReadTimeout,proto3,oneof"`
}
type ClientAuth_NetWriteTimeout struct {
	NetWriteTimeout int32 `protobuf:"varint,4,opt,name=net_write_timeout,json=netWriteTimeout,proto3,oneof"`
}

func (*ClientAuth_NetReadTimeout) isClientAuth_NetReadTimeoutPresent()   {}
func (*ClientAuth_NetWriteTimeout) isClientAuth_NetWriteTimeoutPresent() {}

func (m *ClientAuth) GetNetReadTimeoutPresent() isClientAuth_NetReadTimeoutPresent {
	if m != nil {
		return m.NetReadTimeoutPresent
	}
	return nil
}
func (m *ClientAuth) GetNetWriteTimeoutPresent() isClientAuth_NetWriteTimeoutPresent {
	if m != nil {
		return m.NetWriteTimeoutPresent
	}
	return nil
}

func (m *ClientAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ClientAuth) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *ClientAuth) GetNetReadTimeout() int32 {
	if x, ok := m.GetNetReadTimeoutPresent().(*ClientAuth_NetReadTimeout); ok {
		return x.NetReadTimeout
	}
	return 0
}

func (m *ClientAuth) GetNetWriteTimeout() int32 {
	if x, ok := m.GetNetWriteTimeoutPresent().(*ClientAuth_NetWriteTimeout); ok {
		return x.NetWriteTimeout
	}
	return 0
}

func (m *ClientAuth) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ClientAuth) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientAuth) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ClientAuth) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientAuth) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientAuth_OneofMarshaler, _ClientAuth_OneofUnmarshaler, _ClientAuth_OneofSizer, []interface{}{
		(*ClientAuth_NetReadTimeout)(nil),
		(*ClientAuth_NetWriteTimeout)(nil),
	}
}

func _ClientAuth_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientAuth)
	// net_read_timeout_present
	switch x := m.NetReadTimeoutPresent.(type) {
	case *ClientAuth_NetReadTimeout:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.NetReadTimeout))
	case nil:
	default:
		return fmt.Errorf("ClientAuth.NetReadTimeoutPresent has unexpected type %T", x)
	}
	// net_write_timeout_present
	switch x := m.NetWriteTimeoutPresent.(type) {
	case *ClientAuth_NetWriteTimeout:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.NetWriteTimeout))
	case nil:
	default:
		return fmt.Errorf("ClientAuth.NetWriteTimeoutPresent has unexpected type %T", x)
	}
	return nil
}

func _ClientAuth_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientAuth)
	switch tag {
	case 3: // net_read_timeout_present.net_read_timeout
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.NetReadTimeoutPresent = &ClientAuth_NetReadTimeout{int32(x)}
		return true, err
	case 4: // net_write_timeout_present.net_write_timeout
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.NetWriteTimeoutPresent = &ClientAuth_NetWriteTimeout{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _ClientAuth_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientAuth)
	// net_read_timeout_present
	switch x := m.NetReadTimeoutPresent.(type) {
	case *ClientAuth_NetReadTimeout:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.NetReadTimeout))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// net_write_timeout_present
	switch x := m.NetWriteTimeoutPresent.(type) {
	case *ClientAuth_NetWriteTimeout:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.NetWriteTimeout))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Ack struct {
	// [default = 0]
	//
	// Types that are valid to be assigned to ErrorCodePresent:
	//	*Ack_ErrorCode
	ErrorCodePresent     isAck_ErrorCodePresent `protobuf_oneof:"error_code_present"`
	ErrorMessage         string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{4}
}
func (m *Ack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(dst, src)
}
func (m *Ack) XXX_Size() int {
	return m.Size()
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

type isAck_ErrorCodePresent interface {
	isAck_ErrorCodePresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Ack_ErrorCode struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,oneof"`
}

func (*Ack_ErrorCode) isAck_ErrorCodePresent() {}

func (m *Ack) GetErrorCodePresent() isAck_ErrorCodePresent {
	if m != nil {
		return m.ErrorCodePresent
	}
	return nil
}

func (m *Ack) GetErrorCode() int32 {
	if x, ok := m.GetErrorCodePresent().(*Ack_ErrorCode); ok {
		return x.ErrorCode
	}
	return 0
}

func (m *Ack) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Ack) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Ack_OneofMarshaler, _Ack_OneofUnmarshaler, _Ack_OneofSizer, []interface{}{
		(*Ack_ErrorCode)(nil),
	}
}

func _Ack_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Ack)
	// error_code_present
	switch x := m.ErrorCodePresent.(type) {
	case *Ack_ErrorCode:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ErrorCode))
	case nil:
	default:
		return fmt.Errorf("Ack.ErrorCodePresent has unexpected type %T", x)
	}
	return nil
}

func _Ack_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Ack)
	switch tag {
	case 1: // error_code_present.error_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ErrorCodePresent = &Ack_ErrorCode{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Ack_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Ack)
	// error_code_present
	switch x := m.ErrorCodePresent.(type) {
	case *Ack_ErrorCode:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.ErrorCode))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClientAck struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	BatchId              int64    `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientAck) Reset()         { *m = ClientAck{} }
func (m *ClientAck) String() string { return proto.CompactTextString(m) }
func (*ClientAck) ProtoMessage()    {}
func (*ClientAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{5}
}
func (m *ClientAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientAck.Merge(dst, src)
}
func (m *ClientAck) XXX_Size() int {
	return m.Size()
}
func (m *ClientAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientAck.DiscardUnknown(m)
}

var xxx_messageInfo_ClientAck proto.InternalMessageInfo

func (m *ClientAck) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ClientAck) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientAck) GetBatchId() int64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

// subscription
type Sub struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Filter               string   `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sub) Reset()         { *m = Sub{} }
func (m *Sub) String() string { return proto.CompactTextString(m) }
func (*Sub) ProtoMessage()    {}
func (*Sub) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{6}
}
func (m *Sub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Sub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub.Merge(dst, src)
}
func (m *Sub) XXX_Size() int {
	return m.Size()
}
func (m *Sub) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub.DiscardUnknown(m)
}

var xxx_messageInfo_Sub proto.InternalMessageInfo

func (m *Sub) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Sub) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Sub) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Unsubscription
type Unsub struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Filter               string   `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Unsub) Reset()         { *m = Unsub{} }
func (m *Unsub) String() string { return proto.CompactTextString(m) }
func (*Unsub) ProtoMessage()    {}
func (*Unsub) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{7}
}
func (m *Unsub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Unsub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Unsub.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Unsub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Unsub.Merge(dst, src)
}
func (m *Unsub) XXX_Size() int {
	return m.Size()
}
func (m *Unsub) XXX_DiscardUnknown() {
	xxx_messageInfo_Unsub.DiscardUnknown(m)
}

var xxx_messageInfo_Unsub proto.InternalMessageInfo

func (m *Unsub) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Unsub) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Unsub) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

//  PullRequest
type Get struct {
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId    string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FetchSize   int32  `protobuf:"varint,3,opt,name=fetch_size,json=fetchSize,proto3" json:"fetch_size,omitempty"`
	// [default = -1]
	//
	// Types that are valid to be assigned to TimeoutPresent:
	//	*Get_Timeout
	TimeoutPresent isGet_TimeoutPresent `protobuf_oneof:"timeout_present"`
	// [default = 2]
	//
	// Types that are valid to be assigned to UnitPresent:
	//	*Get_Unit
	UnitPresent isGet_UnitPresent `protobuf_oneof:"unit_present"`
	// [default = false]
	//
	// Types that are valid to be assigned to AutoAckPresent:
	//	*Get_AutoAck
	AutoAckPresent       isGet_AutoAckPresent `protobuf_oneof:"auto_ack_present"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Get) Reset()         { *m = Get{} }
func (m *Get) String() string { return proto.CompactTextString(m) }
func (*Get) ProtoMessage()    {}
func (*Get) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{8}
}
func (m *Get) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Get) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Get.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Get) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Get.Merge(dst, src)
}
func (m *Get) XXX_Size() int {
	return m.Size()
}
func (m *Get) XXX_DiscardUnknown() {
	xxx_messageInfo_Get.DiscardUnknown(m)
}

var xxx_messageInfo_Get proto.InternalMessageInfo

type isGet_TimeoutPresent interface {
	isGet_TimeoutPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGet_UnitPresent interface {
	isGet_UnitPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGet_AutoAckPresent interface {
	isGet_AutoAckPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Get_Timeout struct {
	Timeout int64 `protobuf:"varint,4,opt,name=timeout,proto3,oneof"`
}
type Get_Unit struct {
	Unit int32 `protobuf:"varint,5,opt,name=unit,proto3,oneof"`
}
type Get_AutoAck struct {
	AutoAck bool `protobuf:"varint,6,opt,name=auto_ack,json=autoAck,proto3,oneof"`
}

func (*Get_Timeout) isGet_TimeoutPresent() {}
func (*Get_Unit) isGet_UnitPresent()       {}
func (*Get_AutoAck) isGet_AutoAckPresent() {}

func (m *Get) GetTimeoutPresent() isGet_TimeoutPresent {
	if m != nil {
		return m.TimeoutPresent
	}
	return nil
}
func (m *Get) GetUnitPresent() isGet_UnitPresent {
	if m != nil {
		return m.UnitPresent
	}
	return nil
}
func (m *Get) GetAutoAckPresent() isGet_AutoAckPresent {
	if m != nil {
		return m.AutoAckPresent
	}
	return nil
}

func (m *Get) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Get) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Get) GetFetchSize() int32 {
	if m != nil {
		return m.FetchSize
	}
	return 0
}

func (m *Get) GetTimeout() int64 {
	if x, ok := m.GetTimeoutPresent().(*Get_Timeout); ok {
		return x.Timeout
	}
	return -1
}

func (m *Get) GetUnit() int32 {
	if x, ok := m.GetUnitPresent().(*Get_Unit); ok {
		return x.Unit
	}
	return 2
}

func (m *Get) GetAutoAck() bool {
	if x, ok := m.GetAutoAckPresent().(*Get_AutoAck); ok {
		return x.AutoAck
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Get) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Get_OneofMarshaler, _Get_OneofUnmarshaler, _Get_OneofSizer, []interface{}{
		(*Get_Timeout)(nil),
		(*Get_Unit)(nil),
		(*Get_AutoAck)(nil),
	}
}

func _Get_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Get)
	// timeout_present
	switch x := m.TimeoutPresent.(type) {
	case *Get_Timeout:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Timeout))
	case nil:
	default:
		return fmt.Errorf("Get.TimeoutPresent has unexpected type %T", x)
	}
	// unit_present
	switch x := m.UnitPresent.(type) {
	case *Get_Unit:
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Unit))
	case nil:
	default:
		return fmt.Errorf("Get.UnitPresent has unexpected type %T", x)
	}
	// auto_ack_present
	switch x := m.AutoAckPresent.(type) {
	case *Get_AutoAck:
		t := uint64(0)
		if x.AutoAck {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("Get.AutoAckPresent has unexpected type %T", x)
	}
	return nil
}

func _Get_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Get)
	switch tag {
	case 4: // timeout_present.timeout
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TimeoutPresent = &Get_Timeout{int64(x)}
		return true, err
	case 5: // unit_present.unit
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.UnitPresent = &Get_Unit{int32(x)}
		return true, err
	case 6: // auto_ack_present.auto_ack
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.AutoAckPresent = &Get_AutoAck{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _Get_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Get)
	// timeout_present
	switch x := m.TimeoutPresent.(type) {
	case *Get_Timeout:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Timeout))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// unit_present
	switch x := m.UnitPresent.(type) {
	case *Get_Unit:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Unit))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// auto_ack_present
	switch x := m.AutoAckPresent.(type) {
	case *Get_AutoAck:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

//
type Messages struct {
	BatchId              int64    `protobuf:"varint,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	Messages             [][]byte `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Messages) Reset()         { *m = Messages{} }
func (m *Messages) String() string { return proto.CompactTextString(m) }
func (*Messages) ProtoMessage()    {}
func (*Messages) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{9}
}
func (m *Messages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Messages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Messages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Messages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Messages.Merge(dst, src)
}
func (m *Messages) XXX_Size() int {
	return m.Size()
}
func (m *Messages) XXX_DiscardUnknown() {
	xxx_messageInfo_Messages.DiscardUnknown(m)
}

var xxx_messageInfo_Messages proto.InternalMessageInfo

func (m *Messages) GetBatchId() int64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *Messages) GetMessages() [][]byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

// TBD when new packets are required
type Dump struct {
	Journal  string `protobuf:"bytes,1,opt,name=journal,proto3" json:"journal,omitempty"`
	Position int64  `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// [default = 0]
	//
	// Types that are valid to be assigned to TimestampPresent:
	//	*Dump_Timestamp
	TimestampPresent     isDump_TimestampPresent `protobuf_oneof:"timestamp_present"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Dump) Reset()         { *m = Dump{} }
func (m *Dump) String() string { return proto.CompactTextString(m) }
func (*Dump) ProtoMessage()    {}
func (*Dump) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{10}
}
func (m *Dump) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dump) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dump.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dump) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dump.Merge(dst, src)
}
func (m *Dump) XXX_Size() int {
	return m.Size()
}
func (m *Dump) XXX_DiscardUnknown() {
	xxx_messageInfo_Dump.DiscardUnknown(m)
}

var xxx_messageInfo_Dump proto.InternalMessageInfo

type isDump_TimestampPresent interface {
	isDump_TimestampPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Dump_Timestamp struct {
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp,proto3,oneof"`
}

func (*Dump_Timestamp) isDump_TimestampPresent() {}

func (m *Dump) GetTimestampPresent() isDump_TimestampPresent {
	if m != nil {
		return m.TimestampPresent
	}
	return nil
}

func (m *Dump) GetJournal() string {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *Dump) GetPosition() int64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Dump) GetTimestamp() int64 {
	if x, ok := m.GetTimestampPresent().(*Dump_Timestamp); ok {
		return x.Timestamp
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Dump) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Dump_OneofMarshaler, _Dump_OneofUnmarshaler, _Dump_OneofSizer, []interface{}{
		(*Dump_Timestamp)(nil),
	}
}

func _Dump_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Dump)
	// timestamp_present
	switch x := m.TimestampPresent.(type) {
	case *Dump_Timestamp:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Timestamp))
	case nil:
	default:
		return fmt.Errorf("Dump.TimestampPresent has unexpected type %T", x)
	}
	return nil
}

func _Dump_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Dump)
	switch tag {
	case 3: // timestamp_present.timestamp
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TimestampPresent = &Dump_Timestamp{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Dump_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Dump)
	// timestamp_present
	switch x := m.TimestampPresent.(type) {
	case *Dump_Timestamp:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Timestamp))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClientRollback struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	BatchId              int64    `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientRollback) Reset()         { *m = ClientRollback{} }
func (m *ClientRollback) String() string { return proto.CompactTextString(m) }
func (*ClientRollback) ProtoMessage()    {}
func (*ClientRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_CanalProtocol_79f46d6f01bc36e7, []int{11}
}
func (m *ClientRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientRollback.Merge(dst, src)
}
func (m *ClientRollback) XXX_Size() int {
	return m.Size()
}
func (m *ClientRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientRollback.DiscardUnknown(m)
}

var xxx_messageInfo_ClientRollback proto.InternalMessageInfo

func (m *ClientRollback) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ClientRollback) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientRollback) GetBatchId() int64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func init() {
	proto.RegisterType((*Packet)(nil), "com.alibaba.otter.canal.protocol.Packet")
	proto.RegisterType((*HeartBeat)(nil), "com.alibaba.otter.canal.protocol.HeartBeat")
	proto.RegisterType((*Handshake)(nil), "com.alibaba.otter.canal.protocol.Handshake")
	proto.RegisterType((*ClientAuth)(nil), "com.alibaba.otter.canal.protocol.ClientAuth")
	proto.RegisterType((*Ack)(nil), "com.alibaba.otter.canal.protocol.Ack")
	proto.RegisterType((*ClientAck)(nil), "com.alibaba.otter.canal.protocol.ClientAck")
	proto.RegisterType((*Sub)(nil), "com.alibaba.otter.canal.protocol.Sub")
	proto.RegisterType((*Unsub)(nil), "com.alibaba.otter.canal.protocol.Unsub")
	proto.RegisterType((*Get)(nil), "com.alibaba.otter.canal.protocol.Get")
	proto.RegisterType((*Messages)(nil), "com.alibaba.otter.canal.protocol.Messages")
	proto.RegisterType((*Dump)(nil), "com.alibaba.otter.canal.protocol.Dump")
	proto.RegisterType((*ClientRollback)(nil), "com.alibaba.otter.canal.protocol.ClientRollback")
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.Compression", Compression_name, Compression_value)
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.PacketType", PacketType_name, PacketType_value)
}
func (m *Packet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MagicNumberPresent != nil {
		nn1, err := m.MagicNumberPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.VersionPresent != nil {
		nn2, err := m.VersionPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Type))
	}
	if m.CompressionPresent != nil {
		nn3, err := m.CompressionPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Packet_MagicNumber) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.MagicNumber))
	return i, nil
}
func (m *Packet_Version) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Version))
	return i, nil
}
func (m *Packet_Compression) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Compression))
	return i, nil
}
func (m *HeartBeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendTimestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.SendTimestamp))
	}
	if m.StartTimestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.StartTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Handshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Handshake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommunicationEncodingPresent != nil {
		nn4, err := m.CommunicationEncodingPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if len(m.Seeds) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Seeds)))
		i += copy(dAtA[i:], m.Seeds)
	}
	if m.SupportedCompressions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.SupportedCompressions))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Handshake_CommunicationEncoding) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.CommunicationEncoding)))
	i += copy(dAtA[i:], m.CommunicationEncoding)
	return i, nil
}
func (m *ClientAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientAuth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.NetReadTimeoutPresent != nil {
		nn5, err := m.NetReadTimeoutPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.NetWriteTimeoutPresent != nil {
		nn6, err := m.NetWriteTimeoutPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if len(m.Destination) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if m.StartTimestamp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.StartTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientAuth_NetReadTimeout) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.NetReadTimeout))
	return i, nil
}
func (m *ClientAuth_NetWriteTimeout) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.NetWriteTimeout))
	return i, nil
}
func (m *Ack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCodePresent != nil {
		nn7, err := m.ErrorCodePresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ack_ErrorCode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.ErrorCode))
	return i, nil
}
func (m *ClientAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if m.BatchId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.BatchId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Sub) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Unsub) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Unsub) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Get) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Get) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if m.FetchSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.FetchSize))
	}
	if m.TimeoutPresent != nil {
		nn8, err := m.TimeoutPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.UnitPresent != nil {
		nn9, err := m.UnitPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if m.AutoAckPresent != nil {
		nn10, err := m.AutoAckPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Get_Timeout) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Timeout))
	return i, nil
}
func (m *Get_Unit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Unit))
	return i, nil
}
func (m *Get_AutoAck) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x30
	i++
	if m.AutoAck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Messages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Messages) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.BatchId))
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCanalProtocol(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Dump) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dump) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if m.Position != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Position))
	}
	if m.TimestampPresent != nil {
		nn11, err := m.TimestampPresent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Dump_Timestamp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Timestamp))
	return i, nil
}
func (m *ClientRollback) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientRollback) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if m.BatchId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.BatchId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCanalProtocol(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Packet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MagicNumberPresent != nil {
		n += m.MagicNumberPresent.Size()
	}
	if m.VersionPresent != nil {
		n += m.VersionPresent.Size()
	}
	if m.Type != 0 {
		n += 1 + sovCanalProtocol(uint64(m.Type))
	}
	if m.CompressionPresent != nil {
		n += m.CompressionPresent.Size()
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Packet_MagicNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.MagicNumber))
	return n
}
func (m *Packet_Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Version))
	return n
}
func (m *Packet_Compression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Compression))
	return n
}
func (m *HeartBeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendTimestamp != 0 {
		n += 1 + sovCanalProtocol(uint64(m.SendTimestamp))
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovCanalProtocol(uint64(m.StartTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Handshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommunicationEncodingPresent != nil {
		n += m.CommunicationEncodingPresent.Size()
	}
	l = len(m.Seeds)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.SupportedCompressions != 0 {
		n += 1 + sovCanalProtocol(uint64(m.SupportedCompressions))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Handshake_CommunicationEncoding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommunicationEncoding)
	n += 1 + l + sovCanalProtocol(uint64(l))
	return n
}
func (m *ClientAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.NetReadTimeoutPresent != nil {
		n += m.NetReadTimeoutPresent.Size()
	}
	if m.NetWriteTimeoutPresent != nil {
		n += m.NetWriteTimeoutPresent.Size()
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovCanalProtocol(uint64(m.StartTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientAuth_NetReadTimeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.NetReadTimeout))
	return n
}
func (m *ClientAuth_NetWriteTimeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.NetWriteTimeout))
	return n
}
func (m *Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorCodePresent != nil {
		n += m.ErrorCodePresent.Size()
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ack_ErrorCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.ErrorCode))
	return n
}
func (m *ClientAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.BatchId != 0 {
		n += 1 + sovCanalProtocol(uint64(m.BatchId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Unsub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.FetchSize != 0 {
		n += 1 + sovCanalProtocol(uint64(m.FetchSize))
	}
	if m.TimeoutPresent != nil {
		n += m.TimeoutPresent.Size()
	}
	if m.UnitPresent != nil {
		n += m.UnitPresent.Size()
	}
	if m.AutoAckPresent != nil {
		n += m.AutoAckPresent.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Get_Timeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Timeout))
	return n
}
func (m *Get_Unit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Unit))
	return n
}
func (m *Get_AutoAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Messages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchId != 0 {
		n += 1 + sovCanalProtocol(uint64(m.BatchId))
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			l = len(b)
			n += 1 + l + sovCanalProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovCanalProtocol(uint64(m.Position))
	}
	if m.TimestampPresent != nil {
		n += m.TimestampPresent.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dump_Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Timestamp))
	return n
}
func (m *ClientRollback) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.BatchId != 0 {
		n += 1 + sovCanalProtocol(uint64(m.BatchId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCanalProtocol(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCanalProtocol(x uint64) (n int) {
	return sovCanalProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Packet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Packet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Packet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicNumber", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MagicNumberPresent = &Packet_MagicNumber{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VersionPresent = &Packet_Version{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PacketType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			var v Compression
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Compression(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CompressionPresent = &Packet_Compression{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartBeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartBeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTimestamp", wireType)
			}
			m.SendTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Handshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunicationEncodingPresent = &Handshake_CommunicationEncoding{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seeds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seeds = append(m.Seeds[:0], dAtA[iNdEx:postIndex]...)
			if m.Seeds == nil {
				m.Seeds = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedCompressions", wireType)
			}
			m.SupportedCompressions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupportedCompressions |= (Compression(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetReadTimeout", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetReadTimeoutPresent = &ClientAuth_NetReadTimeout{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetWriteTimeout", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetWriteTimeoutPresent = &ClientAuth_NetWriteTimeout{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorCodePresent = &Ack_ErrorCode{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Unsub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unsub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unsub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Get) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Get: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Get: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchSize", wireType)
			}
			m.FetchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeoutPresent = &Get_Timeout{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnitPresent = &Get_Unit{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutoAckPresent = &Get_AutoAck{b}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Messages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Messages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Messages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, make([]byte, postIndex-iNdEx))
			copy(m.Messages[len(m.Messages)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dump) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dump: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dump: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampPresent = &Dump_Timestamp{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCanalProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCanalProtocol
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCanalProtocol
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCanalProtocol(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCanalProtocol = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCanalProtocol   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("CanalProtocol.proto", fileDescriptor_CanalProtocol_79f46d6f01bc36e7) }

var fileDescriptor_CanalProtocol_79f46d6f01bc36e7 = []byte{
	// 1038 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x5f, 0x6f, 0xe3, 0x44,
	0x10, 0xaf, 0xe3, 0xa4, 0x89, 0x27, 0x69, 0xea, 0x6e, 0xff, 0x28, 0xd7, 0x8a, 0x5c, 0x94, 0x13,
	0xa2, 0xaa, 0x8e, 0x3c, 0x1c, 0x0f, 0xbc, 0x62, 0xa7, 0xa6, 0x8e, 0x9a, 0x26, 0x61, 0xe3, 0xe8,
	0x44, 0x41, 0x44, 0x1b, 0x7b, 0xaf, 0xf5, 0x25, 0xf6, 0x06, 0x7b, 0xcd, 0xa9, 0xf7, 0x49, 0xf8,
	0x20, 0x7c, 0x08, 0x1e, 0x79, 0xe3, 0x15, 0x15, 0x09, 0x89, 0x6f, 0x81, 0x76, 0xed, 0xb8, 0x69,
	0x29, 0xaa, 0xd0, 0xe9, 0xde, 0x76, 0x7e, 0x33, 0x3b, 0xb3, 0xf3, 0x9b, 0xdf, 0xae, 0x0d, 0xbb,
	0x5d, 0x12, 0x92, 0xc5, 0x28, 0x62, 0x9c, 0xb9, 0x6c, 0xd1, 0x59, 0x8a, 0x05, 0x6a, 0xb9, 0x2c,
	0xe8, 0x90, 0x85, 0x3f, 0x23, 0x33, 0xd2, 0x61, 0x9c, 0xd3, 0xa8, 0xe3, 0x8a, 0xb0, 0xd4, 0xed,
	0xb2, 0x45, 0xfb, 0x97, 0x02, 0x6c, 0x8e, 0x88, 0x3b, 0xa7, 0x1c, 0xbd, 0x80, 0x5a, 0x40, 0xae,
	0x7c, 0x77, 0x1a, 0x26, 0xc1, 0x8c, 0x46, 0x0d, 0xa5, 0xa5, 0x1c, 0x97, 0xec, 0x0d, 0x5c, 0x95,
	0xe8, 0x40, 0x82, 0xe8, 0x10, 0xca, 0x3f, 0xd1, 0x28, 0xf6, 0x59, 0xd8, 0x28, 0x48, 0xbf, 0x82,
	0x57, 0x00, 0xfa, 0x0a, 0x8a, 0xfc, 0x66, 0x49, 0x1b, 0x6a, 0x4b, 0x39, 0xae, 0xbf, 0x7a, 0xd9,
	0x79, 0xaa, 0x78, 0x27, 0x2d, 0xec, 0xdc, 0x2c, 0x29, 0x96, 0x3b, 0xd1, 0x37, 0x50, 0x75, 0x59,
	0xb0, 0x8c, 0x68, 0x2c, 0x2b, 0x14, 0x65, 0xa2, 0xcf, 0x9f, 0x4e, 0xd4, 0xbd, 0xdb, 0x64, 0x17,
	0xf0, 0x7a, 0x0e, 0x84, 0xa0, 0x38, 0x63, 0xde, 0x4d, 0xa3, 0xd4, 0x52, 0x8e, 0x6b, 0x58, 0xae,
	0xcd, 0x03, 0xd8, 0x5b, 0xef, 0x74, 0x2a, 0x82, 0x69, 0xc8, 0xcd, 0x1d, 0xd8, 0xce, 0x7a, 0xc9,
	0xa1, 0x7d, 0xd8, 0x5d, 0xcb, 0xb6, 0x82, 0xdb, 0xdf, 0x81, 0x66, 0x53, 0x12, 0x71, 0x93, 0x12,
	0x8e, 0x3e, 0x85, 0x7a, 0x4c, 0x43, 0x6f, 0xca, 0xfd, 0x80, 0xc6, 0x9c, 0x04, 0x4b, 0x49, 0x9d,
	0x8a, 0xb7, 0x04, 0xea, 0xac, 0x40, 0xf4, 0x19, 0x6c, 0xc7, 0x9c, 0x44, 0x7c, 0x2d, 0xae, 0x20,
	0xe3, 0xea, 0x12, 0xce, 0x03, 0xdb, 0xb7, 0x0a, 0x68, 0x36, 0x09, 0xbd, 0xf8, 0x9a, 0xcc, 0x29,
	0xfa, 0x12, 0x0e, 0x5c, 0x16, 0x04, 0x49, 0xe8, 0xbb, 0x84, 0x8b, 0x33, 0xd0, 0xd0, 0x65, 0x9e,
	0x1f, 0x5e, 0xc9, 0x2a, 0x9a, 0xbd, 0x81, 0xf7, 0xef, 0xf9, 0xad, 0xcc, 0x8d, 0xf6, 0xa0, 0x14,
	0x53, 0xea, 0xc5, 0xb2, 0x4a, 0x0d, 0xa7, 0x06, 0xf2, 0xe0, 0x20, 0x4e, 0x96, 0x4b, 0x16, 0x71,
	0xea, 0x4d, 0xd7, 0x5a, 0x8b, 0xb3, 0xb1, 0xfd, 0x3f, 0xb6, 0xf1, 0x7e, 0x9e, 0x6c, 0x0d, 0x8d,
	0xcd, 0x16, 0x34, 0x1f, 0x3f, 0x74, 0xce, 0xe0, 0xef, 0x05, 0x80, 0xee, 0xc2, 0xa7, 0x21, 0x37,
	0x12, 0x7e, 0x8d, 0x0e, 0xa1, 0x92, 0xc4, 0x34, 0x0a, 0x49, 0x40, 0xd3, 0xbe, 0x70, 0x6e, 0x0b,
	0xdf, 0x92, 0xc4, 0xf1, 0x3b, 0x16, 0x79, 0x59, 0x2f, 0xb9, 0x8d, 0x4e, 0x40, 0x0f, 0x29, 0x9f,
	0x46, 0x94, 0xa4, 0xfc, 0xb3, 0x84, 0xcb, 0x46, 0x84, 0x70, 0xeb, 0x21, 0xe5, 0x98, 0x12, 0x39,
	0x02, 0x96, 0x70, 0xf4, 0x12, 0x76, 0x44, 0xec, 0xbb, 0xc8, 0xe7, 0x34, 0x0f, 0x2e, 0x66, 0x2a,
	0xde, 0x0e, 0x29, 0x7f, 0x2d, 0x3c, 0xab, 0xe8, 0x16, 0x54, 0x3d, 0x1a, 0x73, 0x3f, 0x94, 0x0d,
	0x48, 0xfd, 0x68, 0x78, 0x1d, 0x42, 0x47, 0xa0, 0xb9, 0xb2, 0x83, 0xa9, 0xef, 0x35, 0x36, 0xd3,
	0x43, 0xa7, 0x40, 0xcf, 0x43, 0x07, 0xb0, 0xf9, 0xc6, 0x5f, 0x70, 0x1a, 0x35, 0xca, 0xd2, 0x93,
	0x59, 0x8f, 0xa9, 0xa0, 0xf2, 0x98, 0x0a, 0xcc, 0x43, 0x68, 0x3c, 0xec, 0x2c, 0x57, 0xe5, 0x11,
	0x3c, 0xfb, 0x57, 0x27, 0x39, 0xb3, 0x04, 0x54, 0xc3, 0x9d, 0xa3, 0xe7, 0x00, 0x34, 0x8a, 0x58,
	0x34, 0x75, 0x99, 0x47, 0xf3, 0xcb, 0xac, 0x49, 0xac, 0xcb, 0x3c, 0x8a, 0x5e, 0xc0, 0x56, 0x1a,
	0x10, 0xd0, 0x38, 0x26, 0x57, 0x54, 0x72, 0xab, 0xe1, 0x9a, 0x04, 0x2f, 0x52, 0xcc, 0xdc, 0x03,
	0x74, 0x97, 0x25, 0x2f, 0x41, 0x41, 0xcb, 0x66, 0xe7, 0xce, 0x1f, 0x12, 0xa5, 0x3c, 0x41, 0x54,
	0xe1, 0x01, 0x51, 0xcf, 0xa0, 0x32, 0x23, 0xdc, 0xbd, 0x16, 0x3e, 0x55, 0x32, 0x51, 0x96, 0x76,
	0xcf, 0x6b, 0x7f, 0x0f, 0xea, 0x38, 0x99, 0x7d, 0x68, 0x81, 0xff, 0x98, 0x44, 0xfb, 0x07, 0x28,
	0x4d, 0xc2, 0xf8, 0xe3, 0xe5, 0xff, 0x5b, 0x01, 0xf5, 0x8c, 0xf2, 0x0f, 0x4d, 0xff, 0x09, 0xc0,
	0x1b, 0x2a, 0xf8, 0x89, 0xfd, 0xf7, 0xe9, 0xdb, 0x5a, 0xc2, 0x9a, 0x44, 0xc6, 0xfe, 0x7b, 0x71,
	0x39, 0xca, 0xeb, 0x52, 0x56, 0xed, 0x0d, 0xbc, 0x02, 0xd0, 0x1e, 0x14, 0x93, 0xd0, 0xe7, 0x52,
	0xbb, 0x42, 0xe3, 0xd2, 0x42, 0x47, 0x50, 0x21, 0x09, 0x67, 0x53, 0xe2, 0xce, 0xa5, 0x6a, 0x2b,
	0x76, 0x01, 0x97, 0x05, 0x62, 0xb8, 0x73, 0xf1, 0x04, 0x3e, 0x14, 0x5b, 0x1d, 0x6a, 0x62, 0x5f,
	0x6e, 0x23, 0xd0, 0x57, 0xfb, 0x73, 0x41, 0x18, 0x50, 0xc9, 0x14, 0x13, 0xdf, 0x1b, 0xa8, 0x72,
	0x6f, 0xa0, 0xe2, 0x26, 0x67, 0x62, 0x13, 0xaf, 0x92, 0x2a, 0x6e, 0xf2, 0xca, 0x6e, 0xff, 0x08,
	0xc5, 0xd3, 0x24, 0x58, 0xa2, 0x06, 0x94, 0xdf, 0xb2, 0x24, 0x0a, 0xc9, 0x22, 0xa3, 0x6a, 0x65,
	0xca, 0x77, 0x80, 0xc5, 0x3e, 0x5f, 0x7d, 0x7c, 0x54, 0x9c, 0xdb, 0xa8, 0x09, 0xda, 0xdd, 0x85,
	0x52, 0x33, 0x22, 0xee, 0x20, 0x73, 0x17, 0x76, 0x72, 0x23, 0x3f, 0xf5, 0x5b, 0xa8, 0xa7, 0x32,
	0xc6, 0x6c, 0xb1, 0x98, 0x91, 0x8f, 0xa9, 0xe5, 0x93, 0x09, 0x54, 0xd7, 0x5e, 0x48, 0xf4, 0x1c,
	0x8e, 0xba, 0xc3, 0x8b, 0x11, 0xb6, 0xc6, 0xe3, 0xde, 0x70, 0x20, 0x96, 0x86, 0xd3, 0x33, 0xfb,
	0xd6, 0x08, 0x0f, 0x9d, 0xe1, 0x2b, 0x7d, 0x03, 0x55, 0xa0, 0x38, 0x18, 0x0e, 0x2c, 0x5d, 0x11,
	0xab, 0xcb, 0x7e, 0xcf, 0xd4, 0x0b, 0x62, 0x75, 0x76, 0xd9, 0x1b, 0xe9, 0x2a, 0x2a, 0x83, 0xda,
	0xbf, 0xfc, 0x5a, 0x2f, 0x9e, 0xfc, 0xa5, 0x00, 0xdc, 0x7d, 0x46, 0x45, 0xda, 0x91, 0xd1, 0x3d,
	0x37, 0xce, 0x2c, 0xe7, 0xdb, 0x91, 0xf5, 0x48, 0xda, 0x2d, 0xd0, 0x6c, 0x63, 0x70, 0x3a, 0xb6,
	0x8d, 0x73, 0x91, 0xbb, 0x01, 0x7b, 0xdd, 0x7e, 0xcf, 0x1a, 0x38, 0xc6, 0xc4, 0xb1, 0xad, 0x81,
	0xd3, 0xeb, 0x1a, 0x4e, 0x6f, 0x38, 0xd0, 0x0b, 0xa2, 0x82, 0xd1, 0x3d, 0xd7, 0x55, 0xa4, 0x43,
	0x6d, 0x3c, 0x31, 0xc7, 0x5d, 0xdc, 0x1b, 0x49, 0x57, 0x11, 0x21, 0xa8, 0x4f, 0x06, 0xf7, 0xb0,
	0x92, 0x08, 0x3f, 0xb3, 0x1c, 0x7d, 0x13, 0xd5, 0xa0, 0x72, 0x61, 0x8d, 0xc7, 0xc6, 0x99, 0x35,
	0xd6, 0xcb, 0xa2, 0x5c, 0x96, 0xbf, 0x7b, 0xae, 0x57, 0x84, 0x73, 0x6c, 0x4f, 0x9c, 0xd3, 0xe1,
	0xeb, 0x81, 0xae, 0x89, 0x76, 0x4e, 0x27, 0x17, 0x23, 0x1d, 0xe4, 0xa9, 0x2c, 0x03, 0x3b, 0xa6,
	0x65, 0x38, 0x7a, 0x55, 0x14, 0x48, 0x77, 0xe1, 0x61, 0xbf, 0x6f, 0x8a, 0xad, 0x35, 0xd3, 0xf8,
	0xf5, 0xb6, 0xa9, 0xfc, 0x76, 0xdb, 0x54, 0xfe, 0xb8, 0x6d, 0x2a, 0x3f, 0xff, 0xd9, 0xdc, 0x80,
	0x27, 0x7f, 0x6e, 0xcc, 0x6a, 0xfa, 0x4f, 0x24, 0xe9, 0xb1, 0x95, 0xd9, 0xa6, 0x74, 0x7c, 0xf1,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x97, 0x69, 0xe7, 0x75, 0x2b, 0x09, 0x00, 0x00,
}
